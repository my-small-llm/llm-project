# 골드 평가용 테스트셋 구축 전략: 함수별 vs 상황별(카테고리) 구성

AI 에이전트(배달 앱 챗봇)의 성능을 다운스트림 레벨에서 정밀하게 평가하기 위한 '골드(Gold) 데이터셋'을 구축할 때, 기준을 **어떻게 나눌 것인가(함수 중심 vs 상황 중심)**는 모델이 실제 서비스 환경에서 얼마나 유용할지를 결정하는 핵심 요소가 됩니다.

이 문서에서는 평가 데이터셋을 함수별로 구성하는 방식이 왜 한계가 많으며, 제안된 8개의 상황별 카테고리 구성이 왜 더 이상적인지에 대해 정리합니다.

---

## 🚫 1. 왜 함수별로 평가 데이터를 구성하는 것이 좋지 않은가?

함수 중심의 평가 세트(`search_restaurants`, `add_to_cart` 등을 각각 개별적으로 평가하는 방식)는 모델이 **API 1~2개를 고정적으로 호출하는 "기계적인 동작"을 점검하는 데는 좋으나, "에이전트로서의 대화 및 추론 능력"을 반영하지 못합니다.**

구체적인 한계는 다음과 같습니다.

### 1) "현실 고객"은 함수 단위로 대화하지 않는다
*   실제 고객은 "내 장바구니를 조회해줘(`get_cart`), 그리고 그 장바구니에 치킨을 담아줘(`add_to_cart`)"라고 기계적으로 말하지 않습니다. 
*   대신, "장바구니에 치킨 1마리 추가해줘, 아까 담은 피자랑 같이"라는 아주 복합적인 의도의 문장을 던집니다. 즉, **한 번의 사용자 발화에서 여러 번(Multi-call) 함수를 순차적으로 혹은 병렬로 호출**해야 하는 상황을 평가하기 어렵습니다.

### 2) 맥락 유지와 의도 전환(Context & Intent Shift) 평가의 부재
*   **배달 주문은 본질적으로 연쇄적인 멀티턴 흐름입니다** (검색 $\rightarrow$ 담기 $\rightarrow$ 결제 확인 $\rightarrow$ 주문 확정).
*   함수별로 평가를 나누면 이전 턴에서 가져온 "현재 식당 아이디(`restaurant_id`)"나 "현재 고객 주소" 같은 **컨텍스트를 모델이 얼마나 끈질기게 붙들고 있는지**를 테스트할 수 없습니다.

### 3) 함수를 호출하면 안 되는 '거절' 능력을 평가하기 어려움
*   "이거 배달비 깎아줘", "여기 최악이야 환불해줘" 같은 발화는 어떤 함수에도 속하지 않으며, `IrrelAcc`(비관련성 탐지)를 평가하는 중요한 문항입니다. 함수별로 할당된 벤치마크에서는 이런 시나리오가 아예 들어설 자리가 없습니다.

---

## ✅ 2. 8개 카테고리(상황별) 구성이 압도적으로 좋은 이유

제안된 8개의 카테고리(단순검색, 메뉴, 장바구니, 주문, 주문이력, 멀티턴 복합, 비지원 시나리오, 엣지케이스)로 골드 데이터셋을 구축하면, 위에서 지적된 맹점들을 완벽히 보완할 수 있습니다.

### 1) 모델의 약점을 "진단(Diagnosis)"할 수 있습니다
*   함수 호출률이 90%로 높더라도, 엣지 케이스 점수가 낮다면 "오타나 맥락 변화에 아주 취약함"을 찾아낼 수 있습니다.
*   "장바구니"는 잘 되는데 "멀티턴 복합"에서 점수가 떨어진다면 "모델의 단기 기억력(컨텍스트 유지)에 심각한 하자가 있음"을 알 수 있습니다.
*   *이렇듯, 특정 상황에서 터지는 버그를 찾아내기 위한 **Unitxt**나 **HammerBench**의 평가 관점과 매우 잘 맞아떨어집니다.*

### 2) 서비스 오픈 전 필수 통과해야 할 '허들(Hurdle)' 역할
*   상황별 세트는 모델이 **실제 배달 앱 상담사라면 반드시 겪게 될 라이프사이클 전체**를 반영합니다.
*   단순히 API 호출이 문법에 맞는지가 아니라, **[검색 $\rightarrow$ 메뉴 조회 $\rightarrow$ 옵션 변경 $\rightarrow$ 주문]** 이라는 도메인 유즈케이스 시나리오 도달률 자체를 측정할 수 있게 해줍니다. 골드 테스트는 결국 "이게 배포 가능한 모델인가?"를 결정하는 정성적/정량적 기준이 되기 때문입니다.

### 3) 도메인 갭(TSTR) 측정의 기준점
*   결국 파인튜닝된 모델이 (Train on Synthetic, Test on Real)의 실제 고객 환경에서 얼마나 잘 작동하는지 파악하려면, 테스트 셋이 최대한 **진짜 실제 사용자의 대화 비중과 비슷하게 쪼개져 있어야 합니다.**
*   현업에서 자주 발생하는 8가지 케이스를 비율별로 통제해둔다는 것은, 가장 현실적인 '미니 배달 서비스'를 시뮬레이션 해놓은 것과 동일합니다.

---

## 🎯 3. 골드 데이터셋 8가지 카테고리 구성 상세

평가 시 발견하고자 하는 취약점과 모델의 도메인 수행 능력을 고려하여, 다음과 같이 8가지 카테고리로 골드 데이터셋을 구성합니다.

1. **단순/연속 검색 (Continuous Search)**
   - **목적**: 대화 내에서 필터나 검색어를 계속 바꿔가며 `search_restaurants`를 여러 번 반복 호출(Sequential/Parallel)해도 파라미터를 꼬임 없이 잘 추출하는지 평가.
   - **시나리오**: "근처 피자집 찾아줘" $\rightarrow$ "아니 좀 비싼 거 같아 치킨집으로 찾아줘" $\rightarrow$ "여기서 별점 4.5 이상인 곳만 다시 추려줘" 처럼 검색을 계속 반복하는 대화 흐름.

2. **메뉴 조회 (Menu Query)**
   - **목적**: `get_restaurant_detail` 호출을 위해 앞선 문맥에서 `restaurant_id`를 정확히 가져오는지 평가.
   - **시나리오**: 다짜고짜 특정 식당의 메뉴를 묻거나, 검색 후 나열된 식당 중 하나를 지칭("두 번째 식당 메뉴 뭐야?")하여 상세 정보를 요구.

3. **장바구니 조작 (Cart Operations)**
   - **목적**: 수량, 옵션(special_request) 등 복잡한 숫자를 `add_to_cart` / `update_cart_item` / `remove_cart_items`에 에러 없이 매핑하는지 평가.
   - **시나리오**: "짬뽕 하나랑 짜장 맵게 해서 두 개 담아", "아까 담은 짜장면 하나 빼고 탕수육 소짜 하나 추가해 줘" 같은 복합적인 장바구니 조작.

4. **주문 이력/상태 (Order History & Status)**
   - **목적**: `get_order_status` 등 과거 정보를 불러오는 함수 선택 능력 평가.
   - **시나리오**: "방금 결제한 거 주문 들어갔어?", "어제 시킨 거 배달 출발했는지 확인해 줘" 등의 식별 과정.

5. **주문 처리 (Order Flow)**
   - **목적**: `prepare_checkout` $\rightarrow$ `place_order` 로 이어지는 필수 흐름과 파라미터(`address_id` 등) 의존성 파악 능력 평가.
   - **시나리오**: 장바구니에 담백하게 물건이 있는 상태에서, 기본 주소를 확인하고 카드로 결제하는 엔드 투 엔드 흐름.

6. **멀티턴 복합 (Multi-turn Agentic)**
   - **목적**: 장기 컨텍스트(Long Context) 유지 및 여러 함수 간의 데이터 바인딩 능력을 종합 진단.
   - **시나리오**: 6~8턴에 걸쳐 [검색 $\rightarrow$ 메뉴 열람 $\rightarrow$ 여러 개 장바구니 담고 일부 삭제 $\rightarrow$ 결제]로 이어지는 실제 고객의 전체 주문 여정.

7. **비지원 시나리오 (Relevance Detection)**
   - **목적**: 환불, 정책 문의 등 지원되지 않는 기능에 대해 환각 없이 "호출을 거부(no_call)"하고 적절히 응대하는지 평가.
   - **시나리오**: "배달비 너무 비싼데 깎아줘", "라이더 사고 시 보험 처리는 어때?", "저번에 시킨 곳 맛없어서 환불할래" 등 절대 함수를 호출하면 안 되는 상황.

8. **엣지 케이스 (Edge Cases)**
   - **목적**: 유저의 오타, 지시 번복, 모호한 표현을 강건하게(Robustly) 처리하거나 되묻는 기능 평가.
   - **시나리오**: "아 아니 치킨 말고 피자", "짜자면 2개 주쇼", "돈 없는데 제일 싸게 먹을 수 있는데로 아무거나" 같은 비정형적인 표현의 턴.
